<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Juno个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo博客">
<meta property="og:url" content="https://luozuishuai.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo博客">
<meta property="og:description" content="Juno个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Juno">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://luozuishuai.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-面试_01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/%E9%9D%A2%E8%AF%95_01/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/%E9%9D%A2%E8%AF%95_01/">面试题分享-附参考答案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="FullGC多的原因，如何优化"><a href="#FullGC多的原因，如何优化" class="headerlink" title="FullGC多的原因，如何优化"></a>FullGC多的原因，如何优化</h4><p>原因：FullGC触发的原因是老年代满了，需要整堆回收</p>
<p>对象被放到老年代有原因：</p>
<ol>
<li>大对象直接分配到老年代</li>
<li>对象经历了很多次GC，年龄超过15</li>
<li>在Survivor区中，超过某个年龄的对象占比超过50%，超过年龄的对象都转移到老年代</li>
<li>空间分配担保，导致老年代满了，或者需要担保的空间太大无法满足要求</li>
</ol>
<p>优化：</p>
<ol>
<li>增大JVM参数中堆内存的设置，看是否需要修改老年代和新生代的比例</li>
<li>减少不必要的对象创建，对象用完赋null值帮助回收</li>
<li>尽量不定义大对象</li>
<li>如果现在使用的是CMS，评估是否可以使用G1收集器</li>
</ol>
<h4 id="MQ怎么保证消息不丢失？"><a href="#MQ怎么保证消息不丢失？" class="headerlink" title="MQ怎么保证消息不丢失？"></a>MQ怎么保证消息不丢失？</h4><p>MQ保证消息不丢失从两个方面来看：客户端的使用和服务端的配置</p>
<h5 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h5><ol>
<li>发送消息时，使用同步发送或者异步发送+check的机制，保证客户端发送消息时成功被服务端接收了</li>
<li>处理消息时，先进行消息的业务处理，等业务逻辑处理完之后，再返回消息的消费ack，如果ack异常了，可以考虑对消息进行持久化处理</li>
</ol>
<h5 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h5><ol>
<li>在接收到消息后，采用同步刷盘的机制来保存消息到磁盘</li>
<li>主从同步，保证即使遭遇系统宕机、磁盘损坏的情况下也保证消息的不丢失</li>
</ol>
<h4 id="MQ如何处理重复消费"><a href="#MQ如何处理重复消费" class="headerlink" title="MQ如何处理重复消费"></a>MQ如何处理重复消费</h4><ol>
<li>看业务是否具有天然的幂等性，例如在订单类系统中，可以通过使用状态判断来看消息是否已经被处理过了</li>
<li>如果不具备幂等性，可以考虑使用setnx来做，当收到消息之后，获取消息的唯一标示，通过唯一标示来做一个分布式锁，消费结束时如果消费成功，执行ack，这个锁就放着不动；消费失败，释放锁，不执行ack</li>
</ol>
<h4 id="ID生成器的原理"><a href="#ID生成器的原理" class="headerlink" title="ID生成器的原理"></a>ID生成器的原理</h4><p>ID生成器是为了全局生成唯一ID的</p>
<p>比较常见的有UUID、数据库自增主键、雪花算法</p>
<p>雪花算法的结构：时间戳 + 机器ID + 序列号</p>
<h4 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h4><h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><p>大量缓存在同一时间失效，导致大量请求打到MySQL，或者Redis服务不可用了，导致请求直接访问到MySQL</p>
<p>解决方案：</p>
<ol>
<li>失效时间的设置尽量在原定时间上加上一个随机数，避免大量key同时失效</li>
<li>搭建Redis集群，提高可用性</li>
</ol>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><p>缓存击穿主要是因为某个热点key在Redis突然消失了，请求全都打到了MySQL</p>
<p>解决方案：</p>
<ol>
<li>热点key不设置失效时间</li>
<li>避免误删操作（代码、人工）</li>
<li>布隆过滤器</li>
</ol>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>连续请求某一个不存在key，导致请求直接打到数据库</p>
<p>解决方案：</p>
<ol>
<li>如果发现持续访问一个不存在的key，可以在Redis中放一个默认值，或者执行降级</li>
<li>在前端或者web层就校验key的合法性，避免不合法的key放进来</li>
</ol>
<h4 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h4><p>分库分表的策略采用主键id和表个数取模的策略</p>
<p>如果数据量持续增加，可以考虑增加分表的张数，分表数量 * 2，减少数据迁移工作</p>
<p>或者最开始就使用一致性Hash</p>
<p>还可以考虑范围分片的方法，并对历史数据执行归档</p>
<h4 id="CPU-100-的问题"><a href="#CPU-100-的问题" class="headerlink" title="CPU 100% 的问题"></a>CPU 100% 的问题</h4><p>简要步骤：</p>
<ol>
<li>找到最耗CPU的进程</li>
<li>找到最耗CPU的线程</li>
<li>查看堆栈，定位线程在干什么，定位代码</li>
</ol>
<h5 id="步骤一、找到进程"><a href="#步骤一、找到进程" class="headerlink" title="步骤一、找到进程"></a>步骤一、找到进程</h5><ul>
<li>执行top -c，显示进程运行信息列表</li>
<li>键入P(大写)，进程按照CPU使用率排序</li>
<li>找出最耗CPU的进程id，例如10778</li>
</ul>
<h5 id="步骤二、找到线程"><a href="#步骤二、找到线程" class="headerlink" title="步骤二、找到线程"></a>步骤二、找到线程</h5><ul>
<li>执行top -Hp 10778，显示一个进程的线程运行信息列表</li>
<li>键入P(大写)，线程按照CPU使用率排序</li>
<li>找出最耗CPU的线程id，例如10084</li>
</ul>
<h5 id="步骤三、看看线程在干什么"><a href="#步骤三、看看线程在干什么" class="headerlink" title="步骤三、看看线程在干什么"></a>步骤三、看看线程在干什么</h5><ul>
<li>首先将线程PID转化为16进制，使用printf “%x\n” 10084，得到对应16进制为： 2764</li>
<li>通过jstack查看堆栈信息，jstack 10778 | grep ‘0x2764’ -C5 —color，得到线程堆栈</li>
<li>找到线程对应的线程名称，找到对应代码</li>
</ul>
<h4 id="线程池的参数评估"><a href="#线程池的参数评估" class="headerlink" title="线程池的参数评估"></a>线程池的参数评估</h4><h5 id="首先要明确任务的类型"><a href="#首先要明确任务的类型" class="headerlink" title="首先要明确任务的类型"></a>首先要明确任务的类型</h5><p>如果是CPU密集型任务，那么核心线程数设置为：CPU核数+1</p>
<p>如果是IO密集性任务，那么就需要大致估算出IO时间和CPU时间的比例，最佳线程数就是</p>
<p>[(IO耗时&#x2F;CPU耗时)+1]*CPU核数</p>
<p>上面说的是核心线程数，那么最大线程数则可以比核心线程数稍微多一些</p>
<p>然后就是阻塞队列了，阻塞队列不宜使用LinkedBlockingQueue（其实LinkedBlockingQueue也是有界的，为Integer的最大值，并且也可以设置容量），而应该使用有界的ArrayBlockingQueue，这个队列大小也需要根据访问量来估计，减去核心线程数在处理的任务，得出一个数值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/%E9%9D%A2%E8%AF%95_01/" data-id="clgdnr1v1000b54uj5gii6x6t" data-title="面试题分享-附参考答案" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-面试_02" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/%E9%9D%A2%E8%AF%95_02/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>►<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/%E9%9D%A2%E8%AF%95_02/">面试题分享2-附参考答案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="sleep方法和wait方法的区别"><a href="#sleep方法和wait方法的区别" class="headerlink" title="sleep方法和wait方法的区别"></a>sleep方法和wait方法的区别</h2><ul>
<li>sleep方法属于Thread类，wait方法属于Object类。</li>
<li>sleep方法暂停执行指定的时间，让出CPU给其他线程，但其监控状态依然保持，在指定时间过后又会自动恢复运行状态。</li>
<li>在调用sleep方法的过程中，线程不会释放对象锁。</li>
<li>在调用wait方法时，线程会放弃对象锁，进入等待此对象的等待锁池，只有针对此对象调用notify方法后，该线程才能进入对象锁池准备获取<br>对象锁，并进入运行状态。</li>
</ul>
<h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><ol>
<li>大表慢查<ul>
<li>查询慢查询日志，分析查询慢的原因</li>
<li>explain</li>
<li>根据业务请求建立适当索引，可通过索引覆盖等手段</li>
</ul>
</li>
<li>B端后台的复杂查询<ul>
<li>如果数据量实在过大，则考虑Elastic Search</li>
</ul>
</li>
<li>多表查询<ul>
<li>宽表</li>
</ul>
</li>
</ol>
<p>存储速度：快速设备 &gt; 慢速设备 <br><br>cpu 寄存器 &gt; cache &gt; 内存 &gt; redis &gt; Elastic Search &gt; 本系统内部的MySQL &gt; RPC调用的MySQL <br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/%E9%9D%A2%E8%AF%95_02/" data-id="clgdnr1v2000c54uj1szr7f5j" data-title="面试题分享2-附参考答案" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/Redis/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>►<a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/Redis/">Redis</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/Redis/">Redis的原理及应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis的原理及应用"><a href="#Redis的原理及应用" class="headerlink" title="Redis的原理及应用"></a>Redis的原理及应用</h1><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>Redis支持String、Hash、List、Set、ZSet、Bitmap、HyperLogLog、Geospatial等8种数据类型。</p>
<ul>
<li>String: String是Redis基本的数据类型，一个key对应一个value。String类型的值最大能存储512MB。</li>
<li>Hash: Redis Hash是一个键值（key -&gt; value）对集合。 </li>
<li>List: Redis List是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。<br>最多可存储2^31-1(4亿多)个元素。</li>
<li>Set: Set是String类型的无序集合。集合是通过散列表实现的，所以添加、删除、查找的复杂度都是O(1)。 </li>
<li>ZSet: Redis ZSet和Set一样也是String类型元素的集合，且不允许有重复的成员，不同的是，每个元素都会关联一个double类型<br>的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序的。</li>
<li>Bitmap: 通过操作二进制位记录数据。</li>
<li>HyperLogLog: 用于估计一个Set中元素数量的概率性的数据结构。</li>
<li>Geospatial: 用于地理空间关系计算。</li>
</ul>
<h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><p>Redis发布、订阅是一种消息通信模式：发送者（pub）向频道（channel）发送消息，订阅者（sub）接收频道上的消息。Redis客户端可以<br>订阅任意数量的频道，发送者也可以向任意频道发送数据。</br></p>
<p><img src="/images/Redis%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85.png" alt="img.png"></p>
<h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><p>Redis的持久化分为RDB和AOF。</br></p>
<ol>
<li>RDB(Redis DataBase): RDB在指定的时间间隔内对数据进行快照存储。<ul>
<li>RDB文件格式紧凑，方便数据传输和数据恢复。</li>
<li>在保存.rdb快照文件时，父进程会<strong>fork</strong>出一个子进程，由子进程完成具体的持久化操作。</li>
<li>bgsave与save的区别：save会阻塞Redis服务器，直到RDB完成。bgsave是fork子线程，持久化由子线程完成，阻塞只发生在fork子线程的阶段。</li>
<li>全量复制。</li>
</ul>
</li>
<li>AOF(Append Of File): AOF记录对服务器的每次写操作，在Redis重启会重放这些命令来恢复数据<ul>
<li>AOF命令以Redis协议追加和保存每次写操作。</li>
<li>支持对AOF文件进行重写，使得AOF文件的体积不至于过大。</li>
<li>不同的fsync策略（无fsync，每秒fsync，每次写fsync）。</li>
<li>AOF文件是日志格式，容易被操作。</li>
<li>实时复制。</li>
</ul>
</li>
</ol>
<h2 id="Redis集群数据复制原理"><a href="#Redis集群数据复制原理" class="headerlink" title="Redis集群数据复制原理"></a>Redis集群数据复制原理</h2><p>Redis提供了复制功能，可以实现主数据库（Master）中的数据更新后，自动将更新的数据同步到从数据库（Slave）。</br></p>
<p><img src="/images/Redis%E9%9B%86%E7%BE%A4%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86.png" alt="img.png"></p>
<ol>
<li>一个从数据库在启动后，会向主数据库发送SYNC命令</li>
<li>主数据库在接收到SYNC命令后，会开始在后台保存快照（RDB持久化过程），并将保存快照期间接收到的命令缓存起来，生成.rdb快照文件。</li>
<li>在主数据库快照执行完成后，Redis会将快照文件和所有缓存的命令以.rdb快照文件的形式发送给从数据库。</li>
<li>从数据库收到主数据库的.rdb快照文件后，载入该快照文件到本地。</li>
<li>从数据库执行载入后的.rdb快照文件，将数据写入内存中。</li>
<li>1~5过程，称之为复制初始化。</li>
<li>在复制初始化结束后，主数据库在每次收到写命令时，都会将命令同步给从数据库，从而保证主从数据库的数据一致。</li>
</ol>
<h2 id="Redis集群模式及工作原理"><a href="#Redis集群模式及工作原理" class="headerlink" title="Redis集群模式及工作原理"></a>Redis集群模式及工作原理</h2><p>Redis有三种集群模式：主从模式、哨兵模式、Redis Cluster。</br></p>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从模式：所有的写请求都被发送到主数据库上，再由主数据库将数据同步到从数据库上。主数据库主要用于执行写操作和数据同步，从数据库主要用于读操作。</br></p>
<p><img src="/images/Redis%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="img.png"></p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式：在主从模式上添加一个哨兵的角色来监控集群的运行状态。哨兵通过发送命令让Redis服务器返回其运行状态。哨兵是一个独立运行的进程，在检测到Master宕机时会自动<br>将Slave切换成Master，然后通过pub&#x2F;sub模式通知其他服务修改配置文件，完成主备热切。</br></p>
<p><img src="/images/Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="img.png"></p>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis-Cluster"></a>Redis-Cluster</h3><p>Redis-Cluster：Redis-Cluster实现了在多个redis节点之间进行数据分片和数据复制。基于Redis集群的数据自动分片能力，可方便地对Redis集群进行横向扩展，以提高Redis集群的<br>吞吐量。基于redis集群的数据复制能力，在集群中的一部分节点失效或者无法进行通信时，Redis仍然可以基于副本数据对外提供服务，这提高了集群的可用性。</br><br>以下命令是redis 5.x及后续版本创建集群的命令。</br></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1 </span><br></pre></td></tr></table></figure>
<p>–cluster-replicas 参数为数字，1表示每个主节点需要1个从节点</br></p>
<p><img src="/images/Redis%20Cluster%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img.png"></p>
<p>Redis-Cluster有以下特点：</br></p>
<ul>
<li>所有Redis节点彼此通过PING-PONG机制互联，内部使用二进制协议优化传输速度和带宽。</li>
<li>在集群中超过半数的节点检测到某个节点Fail后，将该节点值为Fail状态。</li>
<li>客户端连接集群中的任何一个节点即可对集群进行操作。</li>
<li>Redis-Cluster把所有的物理节点都映射到0~16383的slot上，cluster负责维护每个节点上数据槽的分配。</li>
<li>Redis的数据分配策略：Redis首先对Key使用CRC16算法算出一个结果，然后把结果对16384取余，这样每个key<br>都会对应一个编号为0~16383的slot。</li>
<li>slot可以理解为是Redis节点的别名，比如key1和key2经过分配策略取值都是6000，那这连个key就在包含slot&#x3D;6000的节点上，<br>此时恰好是节点C，那么节点C就保存了key1和key2。 </li>
<li>Redis会根据节点的数量大致均匀地将slot映射到不同的节点。</li>
</ul>
<h2 id="分布式缓存设计的核心问题"><a href="#分布式缓存设计的核心问题" class="headerlink" title="分布式缓存设计的核心问题"></a>分布式缓存设计的核心问题</h2><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><ul>
<li>FIFO(先进先出)：判断被存储的时间，离目前最远的数据优先淘汰。</li>
<li>LRU(最近最少使用)：判断缓存最近被使用的时间，距离当前最远的数据优先被淘汰。</li>
<li>LFU(最不经常使用)：在一段时间内，被使用次数最少的缓存优先被淘汰。</li>
<li>TTL(过期时间)：设置过期时间，时间到期后，缓存淘汰。</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩：在同一时刻由于大量缓存失效，导致大量查询缓存的请求都去查询数据库，对数据库造成巨大压力。</p>
<ul>
<li>设置不同的失效时间</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透：缓存系统故障或者用户频繁查询系统中不存在的数据，这时请求会传过缓存不断被发送到数据库，导致数据库负载过重。</p>
<ul>
<li>布隆过滤器</li>
<li>cache null：在缓存中记录一个短暂的（数据过期时间内）数据在系统中是否存在的状态，如果不存在，直接返回null。</li>
</ul>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><ol>
<li>首先需要k个hash函数，每个函数可以把key散列成为1个整数</li>
<li>初始化时，需要一个长度为n比特的数组，每个比特位初始化为0</li>
<li>某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1</li>
<li>判断某个key是否存在，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为存在。</li>
</ol>
<p>优点：不需要存储key，节省空间 </br></p>
<p>缺点：</br></p>
<ol>
<li>算法判断key在集合中时，有一定的概率key其实不在集合中</li>
<li>无法删除</li>
</ol>
<h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>策略：延迟双删</p>
<ol>
<li>删除redis缓存</li>
<li>更新数据库</li>
<li>更新成功后，通过延迟队列，进行二次删除</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/Redis/" data-id="clgdp6c5m00010oujc2w539pq" data-title="Redis的原理及应用" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis%E9%9B%86%E7%BE%A4/" rel="tag">Redis集群</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" rel="tag">分布式缓存</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" rel="tag">发布和订阅</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0/" rel="tag">延迟双删</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" rel="tag">持久化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">数据类型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" rel="tag">淘汰策略</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" rel="tag">缓存穿透</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" rel="tag">缓存雪崩</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/MySQL/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/MySQL/">MySQL进阶知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL进阶知识点"><a href="#MySQL进阶知识点" class="headerlink" title="MySQL进阶知识点"></a>MySQL进阶知识点</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>不支持事务、行级锁和表锁，在INSERT和UPDATE时会锁定整个表。</br><br>MyISAM的特点是执行读取速度快，且占用的内存和存储资源较少。</br></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB的底层存储是B+树，B+树的每个节点都对应InnoDB的一个Page，Page的大小固定，一般设为16KB。非叶子节点只有键值，叶子节点包含完整的数据。</br><br><img src="/images/B+%E6%A0%91%E7%A4%BA%E4%BE%8B%E5%9B%BE.png" alt="img.png"></p>
<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</br><br>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</br><br>基于非主键索引的查询需要多扫描一棵主键索引树，这个过程称为回表。</br><br>减少回表的方式：<strong>索引覆盖</strong>。</br></p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="MySQL-可重复读"><a href="#MySQL-可重复读" class="headerlink" title="MySQL 可重复读"></a>MySQL 可重复读</h3><p>InnoDB 的行数据有多个版本，每个数据版本有自己的row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id和一致性视图确定数据版本的可见性。</p>
<ul>
<li>可重复读，查询只承认在事务启动前就已经提交完成的数据</li>
<li>读提交，查询只承认在查询语句启动前就已经提交完成的数据</li>
<li>当前读，总是读取已经提交完成的最新版本</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在可重复读隔离级别下，事务在启动的时候就拍了快照。注意：这个快照是基于整库的。</br><br>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向InnoDB 的事务系统申请的，是按申请顺序严格递增的。</br><br>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</br><br>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</br></p>
<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁指对某行数据加锁，是一种排它锁，防止其他事务修改此行。</p>
<ul>
<li>SELECT … FOR UPDATE 语句允许用户一次针对多条记录执行更新。</li>
<li>COMMIT或者ROLLBACK释放锁</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁是对当前操作的整张表加锁，表级锁分为表共享读锁与表独占写锁。<br>使用InnoDB引擎，如果筛选条件里面没有索引字段，就使用表锁，反之，则使用行锁。</p>
<h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>页级锁的锁定粒度介于行级锁和表级锁。表级锁的加锁速度快，但冲突多；行级锁冲突少，但加锁慢；页级锁在二者之间做了平衡，一次锁定相邻的一组记录。</p>
<h3 id="间隙琐"><a href="#间隙琐" class="headerlink" title="间隙琐"></a>间隙琐</h3><p>在Innodb可重复读情况下，解决幻读引入的锁机制，前开后闭原则。</p>
<p><strong>可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/MySQL/" data-id="clgdp6c5x00030ouj1h184xr9" data-title="MySQL进阶知识点" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVCC/" rel="tag">MVCC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="tag">存储引擎</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" rel="tag">数据库锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" rel="tag">隔离级别</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-synchronized解析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/synchronized%E8%A7%A3%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/synchronized%E8%A7%A3%E6%9E%90/">synchronized解析</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="编译-gt-字节码"><a href="#编译-gt-字节码" class="headerlink" title="编译 -&gt; 字节码"></a>编译 -&gt; 字节码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// access flags 0x</span><br><span class="line">public final static Ljava/lang/Object; LOCK</span><br><span class="line"></span><br><span class="line">// access flags 0x</span><br><span class="line">public m1()V</span><br><span class="line">TRYCATCHBLOCK L0 L1 L2 null</span><br><span class="line">TRYCATCHBLOCK L2 L3 L2 null</span><br><span class="line">L</span><br><span class="line">LINENUMBER 13 L</span><br><span class="line">GETSTATIC com/hh/skilljava/javabase/juc/SynchronizeTest.LOCK :</span><br><span class="line">Ljava/lang/Object;</span><br><span class="line">DUP</span><br><span class="line">ASTORE 1</span><br><span class="line">MONITORENTER // MONITORENTER</span><br><span class="line">L</span><br><span class="line">LINENUMBER 15 L</span><br><span class="line">ALOAD 1</span><br><span class="line">MONITOREXIT</span><br><span class="line">L</span><br><span class="line">GOTO L</span><br><span class="line">L</span><br><span class="line">FRAME FULL [com/hh/skilljava/javabase/juc/SynchronizeTest</span><br><span class="line">java/lang/Object] [java/lang/Throwable]</span><br><span class="line">ASTORE 2</span><br><span class="line">ALOAD 1</span><br><span class="line">MONITOREXIT // MONITOREXIT</span><br><span class="line">L</span><br><span class="line">ALOAD 2</span><br><span class="line">ATHROW</span><br><span class="line">L</span><br><span class="line">LINENUMBER 16 L</span><br><span class="line">FRAME CHOP 1</span><br><span class="line">RETURN</span><br><span class="line">L</span><br><span class="line">LOCALVARIABLE this Lcom/hh/skilljava/javabase/juc/SynchronizeTest; L</span><br><span class="line">L6 0</span><br><span class="line">MAXSTACK = 2</span><br><span class="line">MAXLOCALS = 3</span><br><span class="line"></span><br><span class="line">// access flags 0x</span><br><span class="line">public synchronized m2()V</span><br><span class="line">L</span><br><span class="line">LINENUMBER 20 L</span><br><span class="line">RETURN</span><br><span class="line">L</span><br><span class="line">LOCALVARIABLE this Lcom/hh/skilljava/javabase/juc/SynchronizeTest; L</span><br><span class="line">L1 0</span><br><span class="line">MAXSTACK = 0</span><br><span class="line">MAXLOCALS = 1</span><br></pre></td></tr></table></figure>

<p>Synchronized在修饰同步代码块时，是由monitorenter和monitorexit指令来实现同步的。</br><br>进入monitorenter指令后，线程将持有Monitor对象，退出 monitorenter指令后，线程将释放该Monitor对象。(修饰方法，使用标识符，原理相同)</br></p>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>JVM中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个Monitor，Monitor可以和对象一起创建、销毁。Monitor是由ObjectMonitor实现，而ObjectMonitor 是由 C++ 的 ObjectMonitor.hpp文件实现，如下所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">_header = NULL;</span><br><span class="line">_count = 0; // 记录个数</span><br><span class="line">_waiters = 0,</span><br><span class="line">_recursions = 0;</span><br><span class="line">_object = NULL;</span><br><span class="line">_owner = NULL;</span><br><span class="line">_WaitSet = NULL; // 处于 wait 状态的线程，会被加入到 _WaitSet</span><br><span class="line">_WaitSetLock = 0 ;</span><br><span class="line">_Responsible = NULL ;</span><br><span class="line">_succ = NULL ;</span><br><span class="line">_cxq = NULL ;</span><br><span class="line">FreeNext = NULL ;</span><br><span class="line">_EntryList = NULL ; // 处于等待锁 block 状态的线程，会被加入到该列表</span><br><span class="line">_SpinFreq = 0 ;</span><br><span class="line">_SpinClock = 0 ;</span><br><span class="line">OwnerIsThread = 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当多个线程同时访问一段同步代码时，多个线程会先被存放在EntryList集合中，处于block状态的线程，都会被加入到该列表。接下来当线程获取到对象的Monitor时，Monitor是依靠底层操作系统的Mutex Lock来实现互斥的，线程申请Mutex成功，则持有该Mutex，其它线程将无法获取到该Mutex。</br></p>
<font color='red'>
<b>因Monitor是依赖于底层的操作系统实现，存在用户态与内核态之间的切换，所以增加了性能开销。</b>
</font>


<h2 id="Synchronized-优化"><a href="#Synchronized-优化" class="headerlink" title="Synchronized 优化"></a>Synchronized 优化</h2><p>为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的 Java 对象头实现了锁升级功能</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象实例在堆内存中被分为了三个部分：对象头、实例数据和对⻬填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组⻓度三部分组成。<br>Mark Word记录了对象和锁有关的信息。Mark Word在64位JVM中的⻓度是64bit，我们可以一起看下Mark Word在64位JVM的存储结构是怎么样的。如下图所示</p>
<p><img src="/images/java%E5%AF%B9%E8%B1%A1%E5%A4%B4-Mark%20Word.png" alt="img.png"></p>
<p>锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，Synchronized同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>当没有竞争出现时，默认会使用偏向锁。JVM会利用CAS操作，在对象头上的Mark Word部分设置线程 ID，以表示这个对象偏向于当前线程。偏向锁的作用就是，当一个线程再次<br>访问这个同步代码或方法时，该线程只需去对象头的Mark Word中去判断一下是否有偏向锁指向它的ID，无需再进入Monitor去竞争对象了。</br></p>
<font color='red'>
<b>偏向锁主要用来优化同一线程多次申请同一个锁的竞争（例如单线程操作线程安全的集合）。</b>
</font>


<p>在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加JVM参数关闭偏向锁来调优系统性能。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象Mark Word中的线程ID不是自己的线程ID，就会进行CAS操作获取锁，如果获取成功，直接替换Mark Word中的线程ID为自己的ID，该锁会保持偏向锁状态；如果获取锁失败，代表当前<br>锁有一定的竞争，偏向锁将升级为轻量级锁。</br></p>
<font color='red'>
<b>轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在⻓时间的竞争。</b>
</font>


<h3 id="自旋锁和重量级锁"><a href="#自旋锁和重量级锁" class="headerlink" title="自旋锁和重量级锁"></a>自旋锁和重量级锁</h3><p>从JDK1.7开始，自旋锁默认启用，自旋次数由JVM设置决定。</br><br>在尝试升级轻量级锁CAS抢锁失败时，会进行自旋，自旋重试上限后依然没有抢到锁，线程将会被挂起进入阻塞状态。升级为重量级锁，这个状态下，未抢到锁的线程都会进入Monitor，被阻塞在_waitSet 队列中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseBiasedLocking // 关闭偏向锁（默认打开）</span><br></pre></td></tr></table></figure>

<h3 id="动态编译实现锁消除-x2F-锁粗化"><a href="#动态编译实现锁消除-x2F-锁粗化" class="headerlink" title="动态编译实现锁消除 &#x2F; 锁粗化"></a>动态编译实现锁消除 &#x2F; 锁粗化</h3><p>Java还使用了编译器对锁进行优化。JIT编译器在动态编译同步块的时候，借助了一种被称为<font color='red'>逃逸分析</font>的技术，<font color='red'>来判断同步代码块使用的锁对象是否只能够被一个线程访问</font>，编译时直接不生成Synchronized对应的机器码。</br></p>
<p>锁粗化，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。</br></p>
<h3 id="代码层优化"><a href="#代码层优化" class="headerlink" title="代码层优化"></a>代码层优化</h3><p>减小锁粒度，分段锁..</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/synchronized%E8%A7%A3%E6%9E%90/" data-id="clgdp6c6100050ouj3wb7apyt" data-title="synchronized解析" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5%E9%94%81/" rel="tag">同步锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/JVM/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/JVM/">JVM知识点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM知识点"><a href="#JVM知识点" class="headerlink" title="JVM知识点"></a>JVM知识点</h1><h2 id="JVM的运行机制"><a href="#JVM的运行机制" class="headerlink" title="JVM的运行机制"></a>JVM的运行机制</h2><p>JVM是用于运行Java字节码的虚拟机，包括一套字节码指令集、一组程序寄存器、一个虚拟机栈、一个虚拟机堆、一个方法区和一个垃圾回收器。JVM运行在操作系统<br>之上，不与硬件设备直接交互。<br/><br>Java源文件在通过编译器之后被编译成.class文件，.class文件又被JVM中的解释器翻译成机器码在不同的操作系统（Windows、Linux、MacOs）上运行。每种<br>操作系统的解释器都是不同的，但基于解释实现的虚拟机是相同的，这也是Java跨平台的原因。在一个Java进程开始运行后，虚拟机就开始实例化，有多个进程启动就会<br>实例化多个虚拟机实例。进程退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间不能共享数据。<br/><br>Java程序的具体运行过程如下：<br/></p>
<ol>
<li>Java源文件被编译器编译成字节码文件。</li>
<li>JVM将字节码文件翻译成相应操作系统的机器码。</li>
<li>机器码调用相应的操作系统的本地方法库执行相应的方法。</li>
</ol>
<p><img src="/images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%A4%E4%BA%92%E5%9B%BE.png" alt="img.png"></p>
<ul>
<li>类加载器子系统用于将编译好的.class文件加载到JVM中</li>
<li>运行时数据区用于存储JVM运行过程中产生的数据</li>
<li>执行引擎包括即时编译器和垃圾回收器，即时编译器用于将Java字节码翻译成具体的机器码，<br>垃圾回收器用于回收在运行过程中不再使用的对象</li>
<li>本地接口库用于调用操作系统的本地方法库完成具体的指令操作</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>在多核操作系统上，JVM允许在一个进程内同时并发执行多个线程。JVM中的线程与操作系统中的线程是相互对应的，在JVM线程的本地存储、缓冲区分配、同步对象、栈、<br>程序计数器等准备工作都完成时，JVM会调用操作系统的接口创建一个与之对应的原生线程；在JVM线程中运行结束时，原生线程随之会被回收。操作系统负责调度所有线程，<br>并为其分配CPU时间片，在原生线程初始化完毕后，就会调用Java线程的run()方法，执行该线程；在线程结束时，会释放原生线程和Java线程所对应的资源。</br></p>
<p>在JVM后台运行的线程主要有以下几个：</br></p>
<ul>
<li>虚拟机线程：JVM执行任务的线程，执行run()方法</li>
<li>周期性任务线程：通过定时器调度线程，实现周期性操作</li>
<li>GC线程：垃圾回收</li>
<li>编译器线程：编译器线程在运行时将字节码动态编译成本地平台的机器码，是JVM跨平台的体现</li>
<li>信号分发线程：接收发送到JVM信号并调用JVM方法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/JVM/" data-id="clgdp6c6500080oujdia33meu" data-title="JVM知识点" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-自定义注解+AOP切面实现记录操作日志到数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2023-04-12T11:40:04.000Z" itemprop="datePublished">2023-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/">案例分析</a>►<a class="article-category-link" href="/categories/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/">自定义注解+AOP切面实现记录操作日志到数据库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>● 每当有增、删、改、上传等编辑操作时，需要记录日志到数据库，用于溯源。<br>● 记录字段比如：操作人id、名称、ip地址、请求方式、调用方法、参数、操作类型、操作时间、操作模块、返回结果。<br>使用<code>AOP</code>切面编程方式，对增删改操作进行增强，在操作完成后切入，获取所需要的信息，存入数据库。</p>
<h2 id="创建自定义注解"><a href="#创建自定义注解" class="headerlink" title="创建自定义注解"></a>创建自定义注解</h2><p>● 使用<code>@interface</code>创建自定义注解<code>OptLog</code>。<br>● 1个参数：<code>optType</code>，用于记录操作类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> OptLog &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 操作类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">optType</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建常量，定义操作类型"><a href="#创建常量，定义操作类型" class="headerlink" title="创建常量，定义操作类型"></a>创建常量，定义操作类型</h2><p>定义常量做为<code>optType</code>的值，统一规范，方便后期维护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptTypeConst</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SAVE_OR_UPDATE</span> <span class="operator">=</span> <span class="string">&quot;新增或修改&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SAVE</span> <span class="operator">=</span> <span class="string">&quot;新增&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPDATE</span> <span class="operator">=</span> <span class="string">&quot;修改&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REMOVE</span> <span class="operator">=</span> <span class="string">&quot;删除&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD</span> <span class="operator">=</span> <span class="string">&quot;上传&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写切面方法，实现记录日志"><a href="#编写切面方法，实现记录日志" class="headerlink" title="编写切面方法，实现记录日志"></a>编写切面方法，实现记录日志</h2><p>● <code>@Aspect</code>：声明为切面类。<br>● <code>@Pointcut(&quot;@annotation(com.minzheng.blog.annotation.OptLog)&quot;)</code>：在OptLog注解的位置切入代码。<br>● <code>@AfterReturning(value = &quot;optLogPointCut()&quot;, returning = &quot;keys&quot;)</code>：表示对<code>optLogPointCut()</code>方法定义的切入点进行增强的实现方法，returning &#x3D; “keys”表示返回的参数。<br>● 通过<code>RequestContextHolder</code>获取到<code>request</code>，获取请求中的信息。<br>● <code>joinPoint</code>通过反射，获取到切入点所在的方法，以及注解中的内容。<br>● 将信息存入<code>operationLog</code>实体类，最终通过<code>operationLogDao</code>存入数据库。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptLogAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OperationLogDao operationLogDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置操作日志切入点 记录操作日志 在注解的位置切入代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.minzheng.blog.annotation.OptLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">optLogPointCut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常返回通知，拦截用户操作日志，连接点正常执行完成后执行， 如果连接点抛出异常，则不会执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 切入点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys      返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;optLogPointCut()&quot;, returning = &quot;keys&quot;)</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveOptLog</span><span class="params">(JoinPoint joinPoint, Object keys)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取RequestAttributes</span></span><br><span class="line">        <span class="type">RequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="comment">// 从获取RequestAttributes中获取HttpServletRequest的信息</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) Objects.requireNonNull(requestAttributes).resolveReference(RequestAttributes.REFERENCE_REQUEST);</span><br><span class="line">        <span class="type">OperationLog</span> <span class="variable">operationLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OperationLog</span>();</span><br><span class="line">        <span class="comment">// 从切面织入点处通过反射机制获取织入点处的方法</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">signature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        <span class="comment">// 获取切入点所在的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> signature.getMethod();</span><br><span class="line">        <span class="comment">// 获取操作</span></span><br><span class="line">        <span class="type">Api</span> <span class="variable">api</span> <span class="operator">=</span> (Api) signature.getDeclaringType().getAnnotation(Api.class);</span><br><span class="line">        <span class="type">ApiOperation</span> <span class="variable">apiOperation</span> <span class="operator">=</span> method.getAnnotation(ApiOperation.class);</span><br><span class="line">        <span class="type">OptLog</span> <span class="variable">optLog</span> <span class="operator">=</span> method.getAnnotation(OptLog.class);</span><br><span class="line">        <span class="comment">// 操作模块</span></span><br><span class="line">        operationLog.setOptModule(api.tags()[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 操作类型</span></span><br><span class="line">        operationLog.setOptType(optLog.optType());</span><br><span class="line">        <span class="comment">// 操作描述</span></span><br><span class="line">        operationLog.setOptDesc(apiOperation.value());</span><br><span class="line">        <span class="comment">// 获取请求的类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">// 获取请求的方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getName();</span><br><span class="line">        methodName = className + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">        <span class="comment">// 请求方式</span></span><br><span class="line">        operationLog.setRequestMethod(Objects.requireNonNull(request).getMethod());</span><br><span class="line">        <span class="comment">// 请求方法</span></span><br><span class="line">        operationLog.setOptMethod(methodName);</span><br><span class="line">        <span class="comment">// 请求参数</span></span><br><span class="line">        operationLog.setRequestParam(JSON.toJSONString(joinPoint.getArgs()));</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        operationLog.setResponseData(JSON.toJSONString(keys));</span><br><span class="line">        <span class="comment">// 请求用户ID</span></span><br><span class="line">        operationLog.setUserId(UserUtils.getLoginUser().getId());</span><br><span class="line">        <span class="comment">// 请求用户</span></span><br><span class="line">        operationLog.setNickname(UserUtils.getLoginUser().getNickname());</span><br><span class="line">        <span class="comment">// 请求IP</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ipAddress</span> <span class="operator">=</span> IpUtils.getIpAddress(request);</span><br><span class="line">        operationLog.setIpAddress(ipAddress);</span><br><span class="line">        operationLog.setIpSource(IpUtils.getIpSource(ipAddress));</span><br><span class="line">        <span class="comment">// 请求URL</span></span><br><span class="line">        operationLog.setOptUrl(request.getRequestURI());</span><br><span class="line">        operationLogDao.insert(operationLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>段落引用知识点<br>@Around @Before  @After  @AfterReturning 执行顺序为：<br>● Around<br>● AroundBefore<br>● before<br>● method.invoke()<br>● AroundAfter<br>● After<br>● AfterReturning</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://luozuishuai.github.io/2023/04/12/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3+AOP%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="clgdp6c6k000f0ouj7ba4glww" data-title="自定义注解+AOP切面实现记录操作日志到数据库" class="article-share-link">Teilen</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" rel="tag">AOP切面编程</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" rel="tag">自定义注解</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/" rel="tag">记录日志</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/">代码记录</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/">案例分析</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%9F%A5%E8%AF%86%E7%82%B9/">知识点</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ABA/" rel="tag">ABA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" rel="tag">AOP切面编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/" rel="tag">AQS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CountDownLatch/" rel="tag">CountDownLatch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GC/" rel="tag">GC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kakfa/" rel="tag">Kakfa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ/" rel="tag">MQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVCC/" rel="tag">MVCC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis%E9%9B%86%E7%BE%A4/" rel="tag">Redis集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantLock/" rel="tag">ReentrantLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E8%AF%AD%E5%8F%A5/" rel="tag">SQL语句</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cpu/" rel="tag">cpu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/httpclient/" rel="tag">httpclient</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netty/" rel="tag">netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rehash/" rel="tag">rehash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/volatile/" rel="tag">volatile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zookeeper/" rel="tag">zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" rel="tag">分布式缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag">分布式锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="tag">动态代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" rel="tag">发布和订阅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5%E9%94%81/" rel="tag">同步锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" rel="tag">存储引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0/" rel="tag">延迟双删</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" rel="tag">引用类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" rel="tag">持久化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" rel="tag">接口限流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" rel="tag">数据库锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" rel="tag">数据类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" rel="tag">淘汰策略</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A7%92%E6%9D%80/" rel="tag">秒杀</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="tag">策略模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98/" rel="tag">缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" rel="tag">缓存穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" rel="tag">缓存雪崩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" rel="tag">自定义注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/" rel="tag">记录日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" rel="tag">隔离级别</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ABA/" style="font-size: 10px;">ABA</a> <a href="/tags/AOP%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/" style="font-size: 13.33px;">AOP切面编程</a> <a href="/tags/AQS/" style="font-size: 13.33px;">AQS</a> <a href="/tags/CAS/" style="font-size: 13.33px;">CAS</a> <a href="/tags/CountDownLatch/" style="font-size: 10px;">CountDownLatch</a> <a href="/tags/GC/" style="font-size: 16.67px;">GC</a> <a href="/tags/HashMap/" style="font-size: 10px;">HashMap</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/Kakfa/" style="font-size: 10px;">Kakfa</a> <a href="/tags/MQ/" style="font-size: 10px;">MQ</a> <a href="/tags/MVCC/" style="font-size: 13.33px;">MVCC</a> <a href="/tags/MySQL/" style="font-size: 16.67px;">MySQL</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/Redis/" style="font-size: 20px;">Redis</a> <a href="/tags/Redis%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">Redis集群</a> <a href="/tags/ReentrantLock/" style="font-size: 10px;">ReentrantLock</a> <a href="/tags/RocketMQ/" style="font-size: 10px;">RocketMQ</a> <a href="/tags/SQL%E8%AF%AD%E5%8F%A5/" style="font-size: 10px;">SQL语句</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/cpu/" style="font-size: 10px;">cpu</a> <a href="/tags/httpclient/" style="font-size: 10px;">httpclient</a> <a href="/tags/netty/" style="font-size: 10px;">netty</a> <a href="/tags/rehash/" style="font-size: 10px;">rehash</a> <a href="/tags/synchronized/" style="font-size: 10px;">synchronized</a> <a href="/tags/volatile/" style="font-size: 10px;">volatile</a> <a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" style="font-size: 10px;">分布式缓存</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 13.33px;">分布式锁</a> <a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 10px;">动态代理</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">反射</a> <a href="/tags/%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/" style="font-size: 10px;">发布和订阅</a> <a href="/tags/%E5%90%8C%E6%AD%A5%E9%94%81/" style="font-size: 10px;">同步锁</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 16.67px;">多线程</a> <a href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" style="font-size: 10px;">存储引擎</a> <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">布隆过滤器</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 16.67px;">并发</a> <a href="/tags/%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0/" style="font-size: 10px;">延迟双删</a> <a href="/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">引用类型</a> <a href="/tags/%E6%8C%81%E4%B9%85%E5%8C%96/" style="font-size: 10px;">持久化</a> <a href="/tags/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/" style="font-size: 10px;">接口限流</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 16.67px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" style="font-size: 10px;">数据库锁</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">数据类型</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">消息队列</a> <a href="/tags/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/" style="font-size: 10px;">淘汰策略</a> <a href="/tags/%E7%A7%92%E6%9D%80/" style="font-size: 10px;">秒杀</a> <a href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">策略模式</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">线程</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 13.33px;">线程池</a> <a href="/tags/%E7%BC%93%E5%AD%98/" style="font-size: 10px;">缓存</a> <a href="/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" style="font-size: 10px;">缓存穿透</a> <a href="/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" style="font-size: 10px;">缓存雪崩</a> <a href="/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/" style="font-size: 13.33px;">自定义注解</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">虚拟机</a> <a href="/tags/%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97/" style="font-size: 10px;">记录日志</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">链表</a> <a href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" style="font-size: 10px;">隔离级别</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/04/12/1003_%E5%AD%97%E8%8A%82/">字节-面试题</a>
          </li>
        
          <li>
            <a href="/2023/04/12/1001_%E5%A4%A9%E7%9C%BC%E6%9F%A5/">天眼查-面试题</a>
          </li>
        
          <li>
            <a href="/2023/04/12/1002_%E7%90%86%E6%83%B3%E6%B1%BD%E8%BD%A6/">理想汽车-面试题</a>
          </li>
        
          <li>
            <a href="/2023/04/12/1005_%E5%BD%93%E5%BD%93/">当当-面试题</a>
          </li>
        
          <li>
            <a href="/2023/04/12/1004_%E7%BE%8E%E5%9B%A2/">美团-面试题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Juno<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>